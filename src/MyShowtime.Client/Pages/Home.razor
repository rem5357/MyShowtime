@page "/"

@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@using MyShowtime.Client.Services
@using MyShowtime.Client
@using MyShowtime.Shared.Dtos
@using MyShowtime.Shared.Enums
@using MyShowtime.Shared.Requests
@inject MediaLibraryService MediaService
@inject IJSRuntime JS
@implements IDisposable

<PageTitle>MyShowtime Library</PageTitle>

@if (bannerVisible)
{
    <div class="page-banner" role="alert">
        <span>Use Control-Mouse wheel to adjust browser zoom until data fits smoothly without being too small.</span>
        <button type="button" class="dismiss-banner" @onclick="DismissBanner" aria-label="Dismiss zoom tip">&times;</button>
    </div>
}

<div class="dashboard-layout">
    <section class="panel panel-library">
        <header class="panel-header">
            <div>
                <h2 class="panel-title">Local Media Library</h2>
                <p class="panel-subtitle">Browse titles synced from TMDB and manage watch states.</p>
            </div>
            <div class="watch-filters">
                <label><input type="checkbox" @bind="filterUnwatched" @bind:after="ApplyFilters" /> Unwatched</label>
                <label><input type="checkbox" @bind="filterPartial" @bind:after="ApplyFilters" /> Partial</label>
                <label><input type="checkbox" @bind="filterWatched" @bind:after="ApplyFilters" /> Watched</label>
                <label><input type="checkbox" @bind="includeHidden" @bind:after="IncludeHiddenChanged" /> Show hidden</label>
            </div>
        </header>
        @if (libraryError is not null)
        {
            <div class="inline-feedback">@libraryError</div>
        }
        <div class="table-scroll library-table">
            <table class="data-grid">
                <thead>
                    <tr>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortLibrary(LibrarySortTitle)">
                                <span>Title</span>
                                <span class="sort-indicator">@BuildSortIndicator(librarySortColumn, LibrarySortTitle, librarySortAscending)</span>
                            </button>
                        </th>
                        <th scope="col" class="col-center">
                            <button type="button" class="sort-button sort-button-center" @onclick="() => SortLibrary(LibrarySortPriority)">
                                <span>Priority</span>
                                <span class="sort-indicator">@BuildSortIndicator(librarySortColumn, LibrarySortPriority, librarySortAscending)</span>
                            </button>
                        </th>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortLibrary(LibrarySortType)">
                                <span>Type</span>
                                <span class="sort-indicator">@BuildSortIndicator(librarySortColumn, LibrarySortType, librarySortAscending)</span>
                            </button>
                        </th>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortLibrary(LibrarySortRelease)">
                                <span>Released</span>
                                <span class="sort-indicator">@BuildSortIndicator(librarySortColumn, LibrarySortRelease, librarySortAscending)</span>
                            </button>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var item in filteredLibrary)
                    {
                        var isSelected = selectedSummary?.Id == item.Id;
                        <tr class="@BuildMediaRowClasses(item, isSelected)" @onclick="() => SelectMediaAsync(item)">
                            <td>@item.Title</td>
                            <td class="col-center">@item.Priority</td>
                            <td>@(item.MediaType == MediaType.Movie ? "Movie" : "TV Show")</td>
                            <td>@FormatDate(item.ReleaseDate)</td>
                        </tr>
                    }
                </tbody>
            </table>
        </div>
    </section>

    <section class="panel panel-search">
        <header class="panel-header">
            <div>
                <h2 class="panel-title">TMDB Media Search</h2>
                <p class="panel-subtitle">Find new movies or TV shows to import into the library.</p>
            </div>
            <div class="search-controls">
                <input class="form-control" placeholder="Search TMDB..." @bind="searchTerm" @bind:event="oninput" @onkeydown="HandleSearchKeyDown" />
                <div class="search-scope-group" role="radiogroup" aria-label="Search scope">
                    <label class="search-scope-option" for="search-media">
                        <input id="search-media" type="radio" name="search-scope" value="@SearchScopeMedia" checked="@IsSearchType(SearchScopeMedia)" @onchange='@(() => SetSearchType(SearchScopeMedia))' />
                        <span>Media</span>
                    </label>
                    <label class="search-scope-option" for="search-people">
                        <input id="search-people" type="radio" name="search-scope" value="@SearchScopePeople" checked="@IsSearchType(SearchScopePeople)" @onchange='@(() => SetSearchType(SearchScopePeople))' />
                        <span>People</span>
                    </label>
                </div>
                <button class="btn btn-primary" @onclick="TriggerImmediateSearch" disabled="@IsSearchButtonDisabled">@(isSearching ? "Searching..." : "Search")</button>
                <button class="btn btn-outline" @onclick="ClearSearch" disabled="@isSearching && string.IsNullOrWhiteSpace(searchTerm)">Clear</button>
            </div>
        </header>
        <div class="search-hint-row">
            <span class="search-hint">@(!string.IsNullOrWhiteSpace(searchFeedback) ? searchFeedback : "Search TMDB to see results.")</span>
            @if (searchServedFromCache)
            {
                <span class="cache-badge" title="Served from in-memory cache">cache</span>
            }
        </div>
        <div class="table-scroll">
            <table class="data-grid">
                <colgroup>
                    <col style="width:60%" />
                    <col style="width:10%" />
                    <col style="width:10%" />
                    <col style="width:20%" />
                </colgroup>
                <thead>
                    <tr>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortSearch(SearchSortTitle)">
                                <span>Title</span>
                                <span class="sort-indicator">@BuildSortIndicator(searchSortColumn, SearchSortTitle, searchSortAscending)</span>
                            </button>
                        </th>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortSearch(SearchSortType)">
                                <span>Type</span>
                                <span class="sort-indicator">@BuildSortIndicator(searchSortColumn, SearchSortType, searchSortAscending)</span>
                            </button>
                        </th>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortSearch(SearchSortRelease)">
                                <span>Release</span>
                                <span class="sort-indicator">@BuildSortIndicator(searchSortColumn, SearchSortRelease, searchSortAscending)</span>
                            </button>
                        </th>
                        <th scope="col">
                            <button type="button" class="sort-button" @onclick="() => SortSearch(SearchSortSource)">
                                <span>Source</span>
                                <span class="sort-indicator">@BuildSortIndicator(searchSortColumn, SearchSortSource, searchSortAscending)</span>
                            </button>
                        </th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var result in searchResults)
                    {
                        var isSelected = selectedSearchResult?.Id == result.Id && string.Equals(selectedSearchResult.MediaType, result.MediaType, StringComparison.OrdinalIgnoreCase);
                        <tr class="@BuildSearchRowClasses(result, isSelected)" @onclick="() => SelectSearchResultAsync(result)">
                            <td>@result.Title</td>
                            <td>@FormatSearchType(result)</td>
                            <td>@FormatRelease(result.ReleaseDate)</td>
                            <td>@FormatSource(result.Source)</td>
                        </tr>
                    }
                </tbody>
            </table>
            @if (totalSearchPages > 1 && searchResults.Count > 0)
            {
                <div class="table-footer">
                    <button class="btn btn-outline" @onclick="GoToPreviousPage" disabled="@(!CanGoToPreviousPage || isSearching)">Previous</button>
                    <span class="page-indicator">Page @currentSearchPage of @totalSearchPages</span>
                    <button class="btn btn-outline" @onclick="GoToNextPage" disabled="@(!CanGoToNextPage || isSearching)">Next</button>
                </div>
            }
        </div>
    </section>

    <section class="panel panel-details">
        @{
            var activeDetail = searchPreviewDetail ?? selectedDetail;
            var isPreview = searchPreviewDetail is not null;
        }
        @if (activeDetail is null)
        {
            <div class="empty-state">
                <strong>@(isLoadingPreview ? "Loading selection" : "Select a title")</strong>
                @(isLoadingPreview
                    ? "Fetching TMDB details..."
                    : "Choose a media from the library or search results to view details.")
            </div>
        }
        else
        {
            var detail = activeDetail;
            <div class="detail-header">
                <div class="poster">
                    @if (!string.IsNullOrWhiteSpace(detail.PosterPath))
                    {
                        <img src="@BuildPosterUrl(detail.PosterPath)" alt="Poster" />
                    }
                    else
                    {
                        <div class="poster placeholder">No Artwork</div>
                    }
                </div>
                <div class="detail-meta">
                    <div class="detail-title">@detail.Title</div>
                    <div class="detail-subtitle">@(detail.MediaType == MediaType.Movie ? "Movie" : "TV Show") · @FormatDate(detail.ReleaseDate)</div>
                    <div class="detail-tags">
                        <span class="status-pill">Priority @(isPreview ? detail.Priority : updateModel.Priority)</span>
                        <span class="status-pill">@detail.WatchState</span>
                        @if (!isPreview && detail.Hidden)
                        {
                            <span class="status-pill status-hidden">Hidden</span>
                        }
                    </div>
                    <div class="detail-genres">
                        <strong>Genres:</strong> @FormatList(detail.Genres)
                    </div>
                    <div class="detail-cast">
                        <strong>Cast/Crew:</strong>
                        <div class="cast-list">
                            @if (detail.Cast.Any())
                            {
                                foreach (var name in detail.Cast)
                                {
                                    var trimmedName = name?.Trim();
                                    if (!string.IsNullOrWhiteSpace(trimmedName))
                                    {
                                        <button type="button" class="cast-chip" @onclick="async () => await SearchByPersonAsync(trimmedName!)">@trimmedName</button>
                                    }
                                }
                            }
                            else
                            {
                                <span class="cast-empty">Unknown</span>
                            }
                        </div>
                    </div>
                    @if (!string.IsNullOrWhiteSpace(detail.AvailableOn))
                    {
                        <div class="detail-availability">
                            <strong>Available on:</strong> @detail.AvailableOn
                        </div>
                    }
                </div>
            </div>

            <div class="detail-body">
                <div class="detail-actions">
                    @if (isPreview)
                    {
                        <div class="button-row">
                            <button class="btn btn-primary" @onclick="AddPreviewToTrackingAsync" disabled="@(isAddingPreview || isLoadingPreview)">
                                @(isAddingPreview ? "Adding..." : "Add to Tracking")
                            </button>
                        </div>
                    }
                    else
                    {
                        <div class="priority-control">
                            <span class="label">Priority</span>
                            <div class="priority-buttons">
                                <button class="btn btn-outline" @onclick="() => AdjustPriority(-1)" disabled="@isSavingDetail">-</button>
                                <input class="priority-input" value="@updateModel.Priority" readonly />
                                <button class="btn btn-outline" @onclick="() => AdjustPriority(1)" disabled="@isSavingDetail">+</button>
                            </div>
                        </div>
                        <div class="watchstate-control">
                            <span class="label">Watch State</span>
                            <div class="radio-group">
                                <label class="@(IsWatchStateSelected(ViewState.Unwatched) ? "radio-checked" : "")"><input type="radio" name="watch-state" value="Unwatched" checked="@IsWatchStateSelected(ViewState.Unwatched)" @onchange="_ => ChangeWatchState(ViewState.Unwatched)" /> Unwatched</label>
                                <label class="@(IsWatchStateSelected(ViewState.Partial) ? "radio-checked" : "")"><input type="radio" name="watch-state" value="Partial" checked="@IsWatchStateSelected(ViewState.Partial)" @onchange="_ => ChangeWatchState(ViewState.Partial)" disabled="@(selectedDetail?.MediaType == MediaType.TvShow)" /> Partial</label>
                                <label class="@(IsWatchStateSelected(ViewState.Watched) ? "radio-checked" : "")"><input type="radio" name="watch-state" value="Watched" checked="@IsWatchStateSelected(ViewState.Watched)" @onchange="_ => ChangeWatchState(ViewState.Watched)" /> Watched</label>
                            </div>
                        </div>
                        <div class="toggle-group">
                            <button class="btn btn-outline" @onclick="ToggleHidden" disabled="@isSavingDetail">@(updateModel.Hidden ? "Unhide" : "Hide")</button>
                            <button class="btn btn-outline" @onclick="SyncSelectedAsync" disabled="@isSyncing">@(isSyncing ? "Refreshing..." : "Refresh from TMDB")</button>
                        </div>
                    }
                </div>

                <div class="detail-summary">
                    <h3>Overview</h3>
                    <p>@(string.IsNullOrWhiteSpace(detail.Synopsis) ? "No synopsis available." : detail.Synopsis)</p>
                </div>

                @if (!isPreview)
                {
                    <div class="detail-notes">
                        <label class="label">Notes</label>
                        <textarea class="form-control" rows="5" @bind="updateModel.Notes"></textarea>
                        <div class="button-row">
                            <button class="btn btn-primary" @onclick="SaveDetailChanges" disabled="@isSavingDetail">@(isSavingDetail ? "Saving..." : "Save Note")</button>
                        </div>
                    </div>
                }

                @if (!string.IsNullOrWhiteSpace(isPreview ? previewFeedback : detailFeedback))
                {
                    <div class="inline-feedback">@(isPreview ? previewFeedback : detailFeedback)</div>
                }
            </div>
        }
    </section>

    <section class="panel panel-episodes">
        @{
            var episodesDetail = searchPreviewDetail ?? selectedDetail;
            var previewingSearchResult = searchPreviewDetail is not null;
        }
        @if (episodesDetail is null)
        {
            <div class="empty-state">
                <strong>No episode data</strong>
                Select a TV show to view episode details.
            </div>
        }
        else if (previewingSearchResult)
        {
            <div class="empty-state">
                <strong>Episodes unavailable</strong>
                Add this title to tracking to view synced episodes.
            </div>
        }
        else if (episodesDetail.MediaType != MediaType.TvShow)
        {
            <div class="episode-empty-poster">
                <div class="poster">
                    @if (!string.IsNullOrWhiteSpace(episodesDetail.PosterPath))
                    {
                        <img src="@BuildPosterUrl(episodesDetail.PosterPath)" alt="Poster" />
                    }
                    else
                    {
                        <div class="poster placeholder">No Artwork</div>
                    }
                </div>
                <p>This media does not have episodes.</p>
            </div>
        }
        else if (episodes.Count == 0)
        {
            <div class="empty-state">
                <strong>No episodes synced</strong>
                Use refresh to import episodes from TMDB.
            </div>
        }
        else
        {
            <div class="episodes-layout">
                <div class="episode-detail">
                    <h3>Episode Details</h3>
                    @if (selectedEpisodeIds.Count == 0)
                    {
                        <p class="placeholder">Select an episode to view details.</p>
                    }
                    else if (selectedEpisodeIds.Count > 1)
                    {
                        <div class="episode-meta">
                            <div class="episode-title">Multiple Episodes Selected</div>
                            <div class="episode-date">@selectedEpisodeIds.Count episodes selected</div>
                            <div class="episode-watch">
                                <span class="label">Watch State</span>
                                <div class="radio-group">
                                    <label class="@(IsMultiEpisodeWatchState(ViewState.Unwatched) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Unwatched" checked="@IsMultiEpisodeWatchState(ViewState.Unwatched)" @onchange="_ => UpdateMultipleEpisodeStates(ViewState.Unwatched)" /> Unwatched</label>
                                    <label class="@(IsMultiEpisodeWatchState(ViewState.Partial) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Partial" checked="@IsMultiEpisodeWatchState(ViewState.Partial)" @onchange="_ => UpdateMultipleEpisodeStates(ViewState.Partial)" /> Partial</label>
                                    <label class="@(IsMultiEpisodeWatchState(ViewState.Watched) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Watched" checked="@IsMultiEpisodeWatchState(ViewState.Watched)" @onchange="_ => UpdateMultipleEpisodeStates(ViewState.Watched)" /> Watched</label>
                                </div>
                            </div>
                        </div>
                        <div class="episode-synopsis">
                            <strong>Selected Episodes:</strong>
                            <p>@FormatSelectedEpisodes()</p>
                        </div>
                    }
                    else
                    {
                        <div class="episode-meta">
                            <div class="episode-title">@selectedEpisode!.Title (@FormatEpisodeCode(selectedEpisode))</div>
                            <div class="episode-date">Aired @FormatDate(selectedEpisode.AirDate)</div>
                            <div class="episode-watch">
                                <span class="label">Watch State</span>
                                <div class="radio-group">
                                    <label class="@(IsEpisodeWatchState(ViewState.Unwatched) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Unwatched" checked="@IsEpisodeWatchState(ViewState.Unwatched)" @onchange="_ => UpdateEpisodeState(ViewState.Unwatched)" /> Unwatched</label>
                                    <label class="@(IsEpisodeWatchState(ViewState.Partial) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Partial" checked="@IsEpisodeWatchState(ViewState.Partial)" @onchange="_ => UpdateEpisodeState(ViewState.Partial)" /> Partial</label>
                                    <label class="@(IsEpisodeWatchState(ViewState.Watched) ? "radio-checked" : "")"><input type="radio" name="episode-watch" value="Watched" checked="@IsEpisodeWatchState(ViewState.Watched)" @onchange="_ => UpdateEpisodeState(ViewState.Watched)" /> Watched</label>
                                </div>
                            </div>
                        </div>
                        <div class="episode-synopsis">
                            <strong>Synopsis:</strong>
                            <p>@(string.IsNullOrWhiteSpace(selectedEpisode.Synopsis) ? "No synopsis available." : selectedEpisode.Synopsis)</p>
                        </div>
                    }
                </div>
                <div class="episode-list">
                    <div class="episode-list-header">
                        <h3>Episodes</h3>
                        <label><input type="checkbox" @bind="hideSpecials" @bind:after="ApplyEpisodeFilter" /> Hide specials</label>
                    </div>
                    <div class="table-scroll">
                        <table class="data-grid">
                            <thead>
                                <tr>
                                    <th scope="col" class="col-checkbox">
                                        <input type="checkbox" @onchange="ToggleAllEpisodes" checked="@AreAllEpisodesSelected()" />
                                    </th>
                                    <th scope="col">
                                        <button type="button" class="sort-button" @onclick="() => SortEpisodes(EpisodeSortTitle)">
                                            <span>Title</span>
                                            <span class="sort-indicator">@BuildSortIndicator(episodeSortColumn, EpisodeSortTitle, episodeSortAscending)</span>
                                        </button>
                                    </th>
                                    <th scope="col" class="col-center">
                                        <button type="button" class="sort-button sort-button-center" @onclick="() => SortEpisodes(EpisodeSortNumber)">
                                            <span>Episode</span>
                                            <span class="sort-indicator">@BuildSortIndicator(episodeSortColumn, EpisodeSortNumber, episodeSortAscending)</span>
                                        </button>
                                    </th>
                                    <th scope="col">
                                        <button type="button" class="sort-button" @onclick="() => SortEpisodes(EpisodeSortAirDate)">
                                            <span>Air Date</span>
                                            <span class="sort-indicator">@BuildSortIndicator(episodeSortColumn, EpisodeSortAirDate, episodeSortAscending)</span>
                                        </button>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var episode in filteredEpisodes)
                                {
                                    var isSelected = selectedEpisodeIds.Contains(episode.Id);
                                    <tr class="@BuildEpisodeRowClasses(episode, isSelected)" @onclick="(e) => HandleEpisodeRowClick(episode, e)">
                                        <td class="col-checkbox" @onclick:stopPropagation="true">
                                            <input type="checkbox" checked="@isSelected" @onchange="() => ToggleEpisodeSelection(episode.Id)" />
                                        </td>
                                        <td>@episode.Title</td>
                                        <td class="col-center">@FormatEpisodeCode(episode)</td>
                                        <td>@FormatDate(episode.AirDate)</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        }
    </section>
</div>

@code {
    private const string PosterBaseUrl = "https://image.tmdb.org/t/p/w342";
    private const string SearchScopeMedia = "media";
    private const string SearchScopePeople = "person";
    private const string LibrarySortTitle = "title";
    private const string LibrarySortPriority = "priority";
    private const string LibrarySortType = "type";
    private const string LibrarySortRelease = "release";
    private const string SearchSortTitle = "title";
    private const string SearchSortType = "type";
    private const string SearchSortRelease = "release";
    private const string SearchSortSource = "source";
    private const string EpisodeSortTitle = "title";
    private const string EpisodeSortNumber = "episode";
    private const string EpisodeSortAirDate = "airdate";

    private List<MediaSummaryDto> library = new();
    private List<MediaSummaryDto> filteredLibrary = new();
    private List<TmdbSearchItemDto> searchResults = new();
    private List<EpisodeDto> episodes = new();
    private List<EpisodeDto> filteredEpisodes = new();
    private readonly Dictionary<string, TmdbSearchResponseDto> searchCache = new();
    private readonly LinkedList<string> searchCacheOrder = new();
    private const int SearchCacheLimit = 10;
    private CancellationTokenSource? activeSearchRequestCts;
    private CancellationTokenSource? previewCts;
    private long searchRequestVersion;
    private string searchType = SearchScopeMedia;
    private int currentSearchPage = 1;
    private int totalSearchPages = 1;
    private int totalSearchResults;
    private bool searchServedFromCache;
    private string librarySortColumn = LibrarySortPriority;
    private bool librarySortAscending = true;
    private string? searchSortColumn;
    private bool searchSortAscending = true;
    private string episodeSortColumn = EpisodeSortNumber;
    private bool episodeSortAscending = true;
    private bool isDisposed;

    private Guid? lastSelectedMediaId;
    private bool bannerVisible = true;
    private MediaSummaryDto? selectedSummary;
    private MediaDetailDto? selectedDetail;
    private TmdbSearchItemDto? selectedSearchResult;
    private MediaDetailDto? searchPreviewDetail;
    private EpisodeDto? selectedEpisode;
    private readonly HashSet<Guid> selectedEpisodeIds = new();
    private Guid? lastClickedEpisodeId;

    private UpdateMediaRequest updateModel = new()
    {
        Priority = 3,
        WatchState = ViewState.Unwatched
    };

    private string? libraryError;
    private string? searchFeedback;
    private string? detailFeedback;
    private string? previewFeedback;
    private bool isSavingDetail;
    private bool isSyncing;
    private bool isSearching;
    private bool isLoadingPreview;
    private bool isAddingPreview;
    private bool IsPeopleSearch => string.Equals(searchType, SearchScopePeople, StringComparison.OrdinalIgnoreCase);
    private bool IsSearchButtonDisabled => isSearching || (IsPeopleSearch && searchTerm.Trim().Length < 4);
    private bool filterUnwatched = true;
    private bool filterPartial = true;
    private bool filterWatched = true;
    private bool includeHidden;
    private bool hideSpecials = true;
    private string searchTerm = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await ReadLastSelectedMediaAsync();
        bannerVisible = await ShouldShowZoomBannerAsync();
        await LoadLibraryAsync(lastSelectedMediaId);
        await RunSearchAsync(1);
    }

    private async Task LoadLibraryAsync(Guid? preserveSelection = null)
    {
        try
        {
            libraryError = null;
            var items = await MediaService.GetMediaAsync(includeHidden, CancellationToken.None);
            library = items.ToList();
            ApplyFilters();

            if (library.Count == 0)
            {
                selectedSummary = null;
                selectedDetail = null;
                selectedEpisode = null;
                episodes.Clear();
                filteredEpisodes.Clear();
                lastSelectedMediaId = null;
                await SaveLastSelectedMediaAsync(null);
                return;
            }

            var selectionId = preserveSelection ?? selectedSummary?.Id ?? lastSelectedMediaId;
            if (selectionId is not null)
            {
                var summary = library.FirstOrDefault(m => m.Id == selectionId);
                if (summary is not null)
                {
                    await SelectMediaAsync(summary, true);
                }
                else if (lastSelectedMediaId.HasValue)
                {
                    await SaveLastSelectedMediaAsync(null);
                    lastSelectedMediaId = null;
                }
            }
        }
        catch (Exception ex)
        {
            libraryError = $"Failed to load library: {ex.Message}";
        }
    }

    private async Task IncludeHiddenChanged()
    {
        await LoadLibraryAsync(selectedSummary?.Id);
    }

    private void ApplyFilters()
    {
        var query = library.AsEnumerable();
        if (!filterUnwatched)
        {
            query = query.Where(m => m.WatchState != ViewState.Unwatched);
        }
        if (!filterPartial)
        {
            query = query.Where(m => m.WatchState != ViewState.Partial);
        }
        if (!filterWatched)
        {
            query = query.Where(m => m.WatchState != ViewState.Watched);
        }
        if (!includeHidden)
        {
            query = query.Where(m => !m.Hidden);
        }

        filteredLibrary = query.ToList();
        ApplyLibrarySorting();
        StateHasChanged();
    }

    private async Task SelectMediaAsync(MediaSummaryDto summary, bool suppressReload = false)
    {
        if (!suppressReload && summary.Id == selectedSummary?.Id)
        {
            return;
        }

        selectedSummary = summary;
        selectedDetail = null;
        selectedEpisode = null;
        selectedEpisodeIds.Clear();
        lastClickedEpisodeId = null;
        episodes.Clear();
        filteredEpisodes.Clear();
        detailFeedback = null;
        selectedSearchResult = null;
        searchPreviewDetail = null;
        previewFeedback = null;
        isLoadingPreview = false;
        isAddingPreview = false;

        try
        {
            selectedDetail = await MediaService.GetMediaDetailAsync(summary.Id) ?? new MediaDetailDto(
                summary.Id,
                summary.TmdbId,
                summary.MediaType,
                summary.Title,
                summary.ReleaseDate,
                summary.Priority,
                summary.Source,
                summary.WatchState,
                summary.Hidden,
                null,
                null,
                Array.Empty<string>(),
                Array.Empty<string>(),
                null,
                summary.Source,
                summary.CreatedAtUtc,
                summary.UpdatedAtUtc,
                summary.LastSyncedAtUtc);

            updateModel = new UpdateMediaRequest
            {
                Priority = selectedDetail.Priority,
                WatchState = selectedDetail.WatchState,
                Hidden = selectedDetail.Hidden,
                Source = selectedDetail.Source,
                AvailableOn = selectedDetail.AvailableOn,
                Notes = selectedDetail.Notes
            };

            lastSelectedMediaId = summary.Id;
            await SaveLastSelectedMediaAsync(lastSelectedMediaId);

            if (selectedDetail.MediaType == MediaType.TvShow)
            {
                episodes = (await MediaService.GetEpisodesAsync(summary.Id)).ToList();
                ApplyEpisodeFilter();
            }
        }
        catch (Exception ex)
        {
            detailFeedback = $"Failed to load media details: {ex.Message}";
        }
    }

    private void ApplyEpisodeFilter()
    {
        var query = episodes.AsEnumerable();
        if (hideSpecials)
        {
            query = query.Where(e => !e.IsSpecial);
        }
        filteredEpisodes = query.ToList();
        ApplyEpisodeSorting();
    }

    private void HandleEpisodeRowClick(EpisodeDto episode, MouseEventArgs e)
    {
        if (e.ShiftKey && lastClickedEpisodeId.HasValue)
        {
            // Shift-click: Select range
            SelectEpisodeRange(lastClickedEpisodeId.Value, episode.Id);
        }
        else if (e.CtrlKey || e.MetaKey)
        {
            // Ctrl-click (or Cmd-click on Mac): Toggle selection
            ToggleEpisodeSelection(episode.Id);
            lastClickedEpisodeId = episode.Id;
        }
        else
        {
            // Normal click: Select single episode
            selectedEpisodeIds.Clear();
            selectedEpisodeIds.Add(episode.Id);
            lastClickedEpisodeId = episode.Id;
            UpdateSelectedEpisode();
        }
        StateHasChanged();
    }

    private void ToggleEpisodeSelection(Guid episodeId)
    {
        if (selectedEpisodeIds.Contains(episodeId))
        {
            selectedEpisodeIds.Remove(episodeId);
        }
        else
        {
            selectedEpisodeIds.Add(episodeId);
        }
        lastClickedEpisodeId = episodeId;
        UpdateSelectedEpisode();
    }

    private void SelectEpisodeRange(Guid startId, Guid endId)
    {
        var startIndex = filteredEpisodes.FindIndex(e => e.Id == startId);
        var endIndex = filteredEpisodes.FindIndex(e => e.Id == endId);

        if (startIndex < 0 || endIndex < 0) return;

        var minIndex = Math.Min(startIndex, endIndex);
        var maxIndex = Math.Max(startIndex, endIndex);

        for (var i = minIndex; i <= maxIndex; i++)
        {
            selectedEpisodeIds.Add(filteredEpisodes[i].Id);
        }
        UpdateSelectedEpisode();
    }

    private void UpdateSelectedEpisode()
    {
        if (selectedEpisodeIds.Count == 1)
        {
            var id = selectedEpisodeIds.First();
            selectedEpisode = episodes.FirstOrDefault(e => e.Id == id);
        }
        else
        {
            selectedEpisode = null;
        }
    }

    private void ToggleAllEpisodes()
    {
        if (AreAllEpisodesSelected())
        {
            selectedEpisodeIds.Clear();
        }
        else
        {
            selectedEpisodeIds.Clear();
            foreach (var episode in filteredEpisodes)
            {
                selectedEpisodeIds.Add(episode.Id);
            }
        }
        UpdateSelectedEpisode();
        StateHasChanged();
    }

    private bool AreAllEpisodesSelected()
    {
        return filteredEpisodes.Count > 0 && filteredEpisodes.All(e => selectedEpisodeIds.Contains(e.Id));
    }

    private async Task UpdateMultipleEpisodeStates(ViewState state)
    {
        if (selectedSummary is null || selectedEpisodeIds.Count == 0)
        {
            return;
        }

        try
        {
            foreach (var episodeId in selectedEpisodeIds.ToList())
            {
                var updated = await MediaService.UpdateEpisodeViewStateAsync(selectedSummary.Id, episodeId, state);
                if (updated is not null)
                {
                    var index = episodes.FindIndex(e => e.Id == updated.Id);
                    if (index >= 0)
                    {
                        episodes[index] = updated;
                    }
                }
            }

            ApplyEpisodeFilter();
            UpdateSelectedEpisode();

            // Auto-calculate media state for TV shows
            if (selectedDetail?.MediaType == MediaType.TvShow)
            {
                await RecalculateMediaStateAsync();
            }
        }
        catch (Exception ex)
        {
            detailFeedback = $"Episode update failed: {ex.Message}";
        }
    }

    private bool IsMultiEpisodeWatchState(ViewState state)
    {
        if (selectedEpisodeIds.Count <= 1) return false;

        var selectedEpisodes = episodes.Where(e => selectedEpisodeIds.Contains(e.Id)).ToList();
        return selectedEpisodes.Count > 0 && selectedEpisodes.All(e => e.WatchState == state);
    }

    private string FormatSelectedEpisodes()
    {
        var selectedEpisodes = filteredEpisodes.Where(e => selectedEpisodeIds.Contains(e.Id))
            .OrderBy(e => e.SeasonNumber)
            .ThenBy(e => e.EpisodeNumber)
            .Take(10)
            .ToList();

        if (selectedEpisodes.Count == 0) return "None";

        var formatted = string.Join(", ", selectedEpisodes.Select(FormatEpisodeCode));
        if (selectedEpisodeIds.Count > 10)
        {
            formatted += $" and {selectedEpisodeIds.Count - 10} more...";
        }
        return formatted;
    }

    private async Task SelectSearchResultAsync(TmdbSearchItemDto result)
    {
        if (selectedSearchResult?.Id == result.Id
            && string.Equals(selectedSearchResult.MediaType, result.MediaType, StringComparison.OrdinalIgnoreCase)
            && searchPreviewDetail is not null)
        {
            return;
        }

        selectedSearchResult = result;
        searchPreviewDetail = null;
        previewFeedback = null;
        detailFeedback = null;
        selectedSummary = null;
        selectedDetail = null;
        selectedEpisode = null;
        episodes.Clear();
        filteredEpisodes.Clear();

        previewCts?.Cancel();
        previewCts?.Dispose();
        previewCts = new CancellationTokenSource();
        var localCts = previewCts;
        var token = localCts.Token;

        if (string.Equals(result.MediaType, "person", StringComparison.OrdinalIgnoreCase))
        {
            localCts.Cancel();
            localCts.Dispose();
            previewCts = null;
            previewFeedback = "People results are not available to import yet.";
            await SafeStateHasChangedAsync();
            return;
        }

        isLoadingPreview = true;
        await SafeStateHasChangedAsync();

        try
        {
            var preview = await MediaService.GetTmdbPreviewAsync(result.Id, result.MediaType, token);
            if (token.IsCancellationRequested)
            {
                return;
            }

            if (preview is not null)
            {
                searchPreviewDetail = preview;
            }
            else
            {
                previewFeedback = "Unable to load TMDB preview.";
            }
        }
        catch (OperationCanceledException)
        {
            // ignored
        }
        catch (Exception ex)
        {
            previewFeedback = $"Failed to load TMDB preview: {ex.Message}";
        }
        finally
        {
            if (previewCts == localCts)
            {
                previewCts = null;
            }
            localCts.Dispose();
            isLoadingPreview = false;
            await SafeStateHasChangedAsync();
        }
    }

    private async Task AddPreviewToTrackingAsync()
    {
        if (selectedSearchResult is null || isAddingPreview)
        {
            return;
        }

        if (!TryParseMediaType(selectedSearchResult.MediaType, out var mediaType))
        {
            previewFeedback = "People results are not available to add yet.";
            await SafeStateHasChangedAsync();
            return;
        }

        isAddingPreview = true;
        previewFeedback = null;
        await SafeStateHasChangedAsync();

        try
        {
            var request = new ImportMediaRequest
            {
                TmdbId = selectedSearchResult.Id,
                MediaType = mediaType,
                Priority = 3
            };

            var detail = await MediaService.ImportMediaAsync(request);
            if (detail is not null)
            {
                UpsertSummary(detail);
                ApplyFilters();
                searchPreviewDetail = null;
                selectedSearchResult = null;

                await SelectMediaAsync(new MediaSummaryDto(
                    detail.Id,
                    detail.TmdbId,
                    detail.MediaType,
                    detail.Title,
                    detail.ReleaseDate,
                    detail.Priority,
                    detail.Source,
                    detail.WatchState,
                    detail.Hidden,
                    detail.CreatedAtUtc,
                    detail.UpdatedAtUtc,
                    detail.LastSyncedAtUtc));
            }
            else
            {
                previewFeedback = "Unable to add media to tracking.";
            }
        }
        catch (Exception ex)
        {
            previewFeedback = $"Failed to add to tracking: {ex.Message}";
        }
        finally
        {
            isAddingPreview = false;
            await SafeStateHasChangedAsync();
        }
    }

private Task TriggerImmediateSearch()
{
    if (IsSearchButtonDisabled)
    {
        if (IsPeopleSearch)
        {
            searchResults.Clear();
            totalSearchPages = 1;
            totalSearchResults = 0;
            searchServedFromCache = false;
            searchFeedback = "Enter at least four characters to search people.";
            SafeStateHasChanged();
        }
        return Task.CompletedTask;
    }

    currentSearchPage = 1;
    return RunSearchAsync(1);
}

private async Task HandleSearchKeyDown(KeyboardEventArgs args)
{
    if (string.Equals(args.Key, "Enter", StringComparison.OrdinalIgnoreCase) && !IsSearchButtonDisabled)
    {
        currentSearchPage = 1;
        await RunSearchAsync(1);
    }
}

private bool IsSearchType(string value)
    => string.Equals(searchType, value, StringComparison.OrdinalIgnoreCase);

private void SetSearchType(string value)
{
    if (IsSearchType(value))
    {
        return;
    }

    searchType = value.ToLowerInvariant();
    currentSearchPage = 1;
    SafeStateHasChanged();

    if (IsPeopleSearch)
    {
        var trimmed = searchTerm.Trim();
        if (trimmed.Length < 4)
        {
            searchResults.Clear();
            totalSearchPages = 1;
            totalSearchResults = 0;
            searchServedFromCache = false;
            searchFeedback = "Enter at least four characters to search people.";
            SafeStateHasChanged();
            return;
        }

        _ = RunSearchAsync(1);
    }
    else
    {
        _ = RunSearchAsync(1);
    }
}

private async Task RunSearchAsync(int page)
{
    var trimmed = searchTerm.Trim();
    var normalizedType = NormalizeSearchType(searchType);
    var isPerson = normalizedType == "person";

    if (isPerson && trimmed.Length < 4)
    {
        isSearching = false;
        searchResults.Clear();
        totalSearchPages = 1;
        totalSearchResults = 0;
        searchServedFromCache = false;
        searchFeedback = "Enter at least four characters to search people.";
        await SafeStateHasChangedAsync();
        return;
    }

    if (!isPerson && !string.IsNullOrWhiteSpace(trimmed) && trimmed.Length < 2)
    {
        isSearching = false;
        searchResults.Clear();
        totalSearchPages = 1;
        totalSearchResults = 0;
        searchServedFromCache = false;
        searchFeedback = "Keep typing to search TMDB.";
        await SafeStateHasChangedAsync();
        return;
    }

    var requestVersion = ++searchRequestVersion;

    activeSearchRequestCts?.Cancel();
    activeSearchRequestCts?.Dispose();
    var requestCts = new CancellationTokenSource();
    activeSearchRequestCts = requestCts;

    var targetPage = isPerson ? 1 : (page <= 0 ? 1 : page);
    var cacheKey = BuildSearchCacheKey(trimmed, normalizedType, targetPage);

    if (TryGetCachedSearch(cacheKey, out var cached))
    {
        ApplySearchResponse(cached with { ServedFromCache = true }, requestVersion);
        isSearching = false;
        await SafeStateHasChangedAsync();
        if (activeSearchRequestCts == requestCts)
        {
            activeSearchRequestCts = null;
        }
        requestCts.Dispose();
        return;
    }

    isSearching = true;
    searchFeedback = isPerson
        ? "Searching people..."
        : (string.IsNullOrWhiteSpace(trimmed) ? "Loading trending..." : "Searching TMDB...");
    await SafeStateHasChangedAsync();

    try
    {
        var response = await MediaService.SearchTmdbAsync(isPerson ? trimmed : trimmed, normalizedType, targetPage, requestCts.Token);
        CacheSearch(cacheKey, response);
        ApplySearchResponse(response, requestVersion);
    }
    catch (OperationCanceledException)
    {
        // intentionally ignored
    }
    catch (Exception ex)
    {
        if (requestVersion == searchRequestVersion)
        {
            searchResults.Clear();
            totalSearchPages = 1;
            totalSearchResults = 0;
            searchServedFromCache = false;
            searchFeedback = $"Search failed: {ex.Message}";
            await SafeStateHasChangedAsync();
        }
    }
    finally
    {
        if (activeSearchRequestCts == requestCts)
        {
            activeSearchRequestCts.Dispose();
            activeSearchRequestCts = null;
        }

        if (requestVersion == searchRequestVersion)
        {
            isSearching = false;
            await SafeStateHasChangedAsync();
        }
    }
}

    private void ApplySearchResponse(TmdbSearchResponseDto response, long requestVersion)
    {
        if (requestVersion != searchRequestVersion)
        {
            return;
        }

        var previousSelection = selectedSearchResult;
        var previousPreview = searchPreviewDetail;

        searchResults = response.Results
            .Where(r => !string.Equals(r.MediaType, "person", StringComparison.OrdinalIgnoreCase))
            .ToList();
        currentSearchPage = response.Page;
        totalSearchPages = Math.Max(1, response.TotalPages);
        totalSearchResults = response.TotalResults;
        searchServedFromCache = response.ServedFromCache;

        if (previousSelection is not null)
        {
            var updatedSelection = searchResults.FirstOrDefault(r =>
                r.Id == previousSelection.Id &&
                string.Equals(r.MediaType, previousSelection.MediaType, StringComparison.OrdinalIgnoreCase));

            if (updatedSelection is not null)
            {
                selectedSearchResult = updatedSelection;
                searchPreviewDetail = previousPreview;
            }
            else
            {
                selectedSearchResult = null;
                searchPreviewDetail = null;
                previewFeedback = null;
                isLoadingPreview = false;
                isAddingPreview = false;
            }
        }
        else
        {
            selectedSearchResult = null;
            searchPreviewDetail = null;
        }

        ApplySearchSort();
        searchFeedback = BuildSearchFeedback();
        SafeStateHasChanged();
    }

    private string BuildSearchCacheKey(string query, string mediaTypeValue, int page)
        => $"{mediaTypeValue}:{query.ToLowerInvariant()}:{page}";

    private void CacheSearch(string key, TmdbSearchResponseDto response)
    {
        searchCache[key] = response with { ServedFromCache = false };

        if (searchCacheOrder.Contains(key))
        {
            searchCacheOrder.Remove(key);
        }
        searchCacheOrder.AddLast(key);

        while (searchCacheOrder.Count > SearchCacheLimit)
        {
            var oldest = searchCacheOrder.First?.Value;
            if (oldest is null)
            {
                break;
            }

            searchCacheOrder.RemoveFirst();
            searchCache.Remove(oldest);
        }
    }

    private bool TryGetCachedSearch(string key, out TmdbSearchResponseDto response)
    {
        if (searchCache.TryGetValue(key, out var cached))
        {
            searchCacheOrder.Remove(key);
            searchCacheOrder.AddLast(key);
            response = cached;
            return true;
        }

        response = TmdbSearchResponseDtoExtensions.Empty;
        return false;
    }

    private string BuildSearchFeedback()
    {
        if (searchResults.Count == 0)
        {
            if (IsPeopleSearch)
            {
                return searchTerm.Trim().Length >= 4
                    ? $"No matches for '{searchTerm}'."
                    : "Enter at least four characters to search people.";
            }

            return string.IsNullOrWhiteSpace(searchTerm)
                ? "No trending titles right now."
                : $"No results for '{searchTerm}'.";
        }

        var cacheSuffix = searchServedFromCache ? " (cached)" : string.Empty;

        if (IsPeopleSearch)
        {
            return $"Found {searchResults.Count} titles featuring \"{searchTerm}\"{cacheSuffix}";
        }

        if (string.IsNullOrWhiteSpace(searchTerm))
        {
            return $"Trending now — showing {searchResults.Count} titles{cacheSuffix}";
        }

        var pageInfo = totalSearchPages > 1 ? $" • page {currentSearchPage} of {totalSearchPages}" : string.Empty;
        var totalInfo = totalSearchResults > 0
            ? totalSearchResults.ToString("N0", System.Globalization.CultureInfo.InvariantCulture)
            : searchResults.Count.ToString(System.Globalization.CultureInfo.InvariantCulture);
        return $"Showing {totalInfo} results{pageInfo}{cacheSuffix}";
    }

    private bool CanGoToPreviousPage => currentSearchPage > 1;
    private bool CanGoToNextPage => currentSearchPage < totalSearchPages;

    private void GoToPreviousPage()
    {
        if (CanGoToPreviousPage)
        {
            _ = RunSearchAsync(currentSearchPage - 1);
        }
    }

    private void GoToNextPage()
    {
        if (CanGoToNextPage)
        {
            _ = RunSearchAsync(currentSearchPage + 1);
        }
    }

    private void SortLibrary(string column)
    {
        if (string.Equals(librarySortColumn, column, StringComparison.OrdinalIgnoreCase))
        {
            librarySortAscending = !librarySortAscending;
        }
        else
        {
            librarySortColumn = column;
            librarySortAscending = true;
        }

        ApplyLibrarySorting();
        StateHasChanged();
    }

    private void SortSearch(string column)
    {
        if (string.Equals(searchSortColumn, column, StringComparison.OrdinalIgnoreCase))
        {
            searchSortAscending = !searchSortAscending;
        }
        else
        {
            searchSortColumn = column;
            searchSortAscending = true;
        }

        ApplySearchSort();
        StateHasChanged();
    }

    private void SortEpisodes(string column)
    {
        if (string.Equals(episodeSortColumn, column, StringComparison.OrdinalIgnoreCase))
        {
            episodeSortAscending = !episodeSortAscending;
        }
        else
        {
            episodeSortColumn = column;
            episodeSortAscending = true;
        }

        ApplyEpisodeSorting();
        StateHasChanged();
    }

    private void ApplyLibrarySorting()
    {
        if (filteredLibrary.Count == 0)
        {
            return;
        }

        filteredLibrary = SortLibraryItems(filteredLibrary, librarySortColumn, librarySortAscending).ToList();
    }

    private static IEnumerable<MediaSummaryDto> SortLibraryItems(IEnumerable<MediaSummaryDto> items, string column, bool ascending)
        => column switch
        {
            LibrarySortTitle => ascending
                ? items.OrderBy(m => m.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(m => m.Title, StringComparer.OrdinalIgnoreCase),
            LibrarySortType => ascending
                ? items.OrderBy(m => m.MediaType).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(m => m.MediaType).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase),
            LibrarySortRelease => ascending
                ? items.OrderBy(m => m.ReleaseDate ?? DateOnly.MaxValue).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(m => m.ReleaseDate ?? DateOnly.MinValue).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase),
            _ => ascending
                ? items.OrderBy(m => m.Priority).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(m => m.Priority).ThenBy(m => m.Title, StringComparer.OrdinalIgnoreCase)
        };

    private void ApplySearchSort()
    {
        if (searchResults.Count == 0 || string.IsNullOrWhiteSpace(searchSortColumn))
        {
            return;
        }

        searchResults = SortSearchItems(searchResults, searchSortColumn!, searchSortAscending).ToList();
    }

    private static IEnumerable<TmdbSearchItemDto> SortSearchItems(IEnumerable<TmdbSearchItemDto> items, string column, bool ascending)
        => column switch
        {
            SearchSortTitle => ascending
                ? items.OrderBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(r => r.Title, StringComparer.OrdinalIgnoreCase),
            SearchSortType => ascending
                ? items
                    .OrderBy(r => GetSearchTypeKey(r), StringComparer.OrdinalIgnoreCase)
                    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
                : items
                    .OrderByDescending(r => GetSearchTypeKey(r), StringComparer.OrdinalIgnoreCase)
                    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase),
            SearchSortRelease => ascending
                ? items.OrderBy(r => ParseReleaseDate(r.ReleaseDate) ?? DateOnly.MaxValue).ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(r => ParseReleaseDate(r.ReleaseDate) ?? DateOnly.MinValue).ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase),
            SearchSortSource => ascending
                ? items
                    .OrderBy(r => string.IsNullOrWhiteSpace(r.Source))
                    .ThenBy(r => r.Source ?? string.Empty, StringComparer.OrdinalIgnoreCase)
                    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase)
                : items
                    .OrderBy(r => string.IsNullOrWhiteSpace(r.Source))
                    .ThenByDescending(r => r.Source ?? string.Empty, StringComparer.OrdinalIgnoreCase)
                    .ThenBy(r => r.Title, StringComparer.OrdinalIgnoreCase),
            _ => items
        };

    private void ApplyEpisodeSorting()
    {
        if (filteredEpisodes.Count == 0)
        {
            return;
        }

        filteredEpisodes = SortEpisodeItems(filteredEpisodes, episodeSortColumn, episodeSortAscending).ToList();
    }

    private static IEnumerable<EpisodeDto> SortEpisodeItems(IEnumerable<EpisodeDto> items, string column, bool ascending)
        => column switch
        {
            EpisodeSortTitle => ascending
                ? items.OrderBy(e => e.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(e => e.Title, StringComparer.OrdinalIgnoreCase),
            EpisodeSortAirDate => ascending
                ? items.OrderBy(e => e.AirDate ?? DateOnly.MaxValue).ThenBy(e => e.Title, StringComparer.OrdinalIgnoreCase)
                : items.OrderByDescending(e => e.AirDate ?? DateOnly.MinValue).ThenBy(e => e.Title, StringComparer.OrdinalIgnoreCase),
            _ => ascending
                ? items.OrderBy(e => e.SeasonNumber).ThenBy(e => e.EpisodeNumber)
                : items.OrderByDescending(e => e.SeasonNumber).ThenByDescending(e => e.EpisodeNumber)
        };

    private async Task ClearSearch()
    {
        searchTerm = string.Empty;
        currentSearchPage = 1;
        if (IsPeopleSearch)
        {
            searchResults.Clear();
            totalSearchPages = 1;
            totalSearchResults = 0;
            searchServedFromCache = false;
            searchFeedback = "Enter at least four characters to search people.";
            SafeStateHasChanged();
            return;
        }

        await RunSearchAsync(1);
    }

    private async Task SearchByPersonAsync(string name)
    {
        var trimmed = name.Trim();
        if (string.IsNullOrWhiteSpace(trimmed))
        {
            return;
        }

        searchType = SearchScopePeople;
        searchTerm = trimmed;
        currentSearchPage = 1;
        SafeStateHasChanged();

        await RunSearchAsync(1);
    }

    private void UpsertSummary(MediaDetailDto detail)
    {
        var summary = new MediaSummaryDto(
            detail.Id,
            detail.TmdbId,
            detail.MediaType,
            detail.Title,
            detail.ReleaseDate,
            detail.Priority,
            detail.Source,
            detail.WatchState,
            detail.Hidden,
            detail.CreatedAtUtc,
            detail.UpdatedAtUtc,
            detail.LastSyncedAtUtc);

        var index = library.FindIndex(m => m.Id == detail.Id);
        if (index >= 0)
        {
            library[index] = summary;
        }
        else
        {
            library.Insert(0, summary);
        }
    }

    private async Task SaveDetailChanges()
    {
        if (selectedSummary is null)
        {
            return;
        }

        isSavingDetail = true;
        detailFeedback = null;
        try
        {
            var detail = await MediaService.UpdateMediaAsync(selectedSummary.Id, updateModel);
            if (detail is not null)
            {
                selectedDetail = detail;
                UpsertSummary(detail);
                ApplyFilters();
                selectedSummary = library.FirstOrDefault(m => m.Id == detail.Id);
            }
            else
            {
                detailFeedback = "Unable to save changes.";
            }
        }
        catch (Exception ex)
        {
            detailFeedback = $"Save failed: {ex.Message}";
        }
        finally
        {
            isSavingDetail = false;
        }
    }

    private async Task ChangeWatchState(ViewState state)
    {
        if (updateModel.WatchState == state)
        {
            return;
        }

        // For TV shows, handle bulk episode updates with confirmation
        if (selectedDetail?.MediaType == MediaType.TvShow && selectedSummary is not null)
        {
            if (state == ViewState.Watched)
            {
                if (!await ConfirmBulkUpdateAsync("Set all Season 1+ episodes to Watched?"))
                {
                    return;
                }

                detailFeedback = "Updating all episodes...";
                StateHasChanged();

                try
                {
                    var success = await MediaService.BulkUpdateEpisodesAsync(selectedSummary.Id, ViewState.Watched, excludeSpecials: true);
                    if (success)
                    {
                        // Reload episodes
                        episodes = (await MediaService.GetEpisodesAsync(selectedSummary.Id)).ToList();
                        ApplyEpisodeFilter();

                        // Auto-calculate and set media state
                        await RecalculateMediaStateAsync();
                        detailFeedback = null;
                    }
                    else
                    {
                        detailFeedback = "Failed to update episodes.";
                    }
                }
                catch (Exception ex)
                {
                    detailFeedback = $"Bulk update failed: {ex.Message}";
                }
            }
            else if (state == ViewState.Unwatched)
            {
                if (!await ConfirmBulkUpdateAsync("Set all episodes to Unwatched?"))
                {
                    return;
                }

                detailFeedback = "Updating all episodes...";
                StateHasChanged();

                try
                {
                    var success = await MediaService.BulkUpdateEpisodesAsync(selectedSummary.Id, ViewState.Unwatched, excludeSpecials: false);
                    if (success)
                    {
                        // Reload episodes
                        episodes = (await MediaService.GetEpisodesAsync(selectedSummary.Id)).ToList();
                        ApplyEpisodeFilter();

                        // Auto-calculate and set media state
                        await RecalculateMediaStateAsync();
                        detailFeedback = null;
                    }
                    else
                    {
                        detailFeedback = "Failed to update episodes.";
                    }
                }
                catch (Exception ex)
                {
                    detailFeedback = $"Bulk update failed: {ex.Message}";
                }
            }
            // Partial state is disabled for TV shows, so this shouldn't be reached
            return;
        }

        // For movies, just update the watch state directly
        updateModel.WatchState = state;
        await SaveDetailChanges();
    }

    private async Task AdjustPriority(int delta)
    {
        var newValue = Math.Clamp(updateModel.Priority + delta, 0, 10);
        if (newValue == updateModel.Priority)
        {
            return;
        }
        updateModel.Priority = newValue;
        await SaveDetailChanges();
    }

    private async Task ToggleHidden()
    {
        updateModel.Hidden = !updateModel.Hidden;
        await SaveDetailChanges();
        await LoadLibraryAsync(selectedSummary?.Id);
    }

    private async Task SyncSelectedAsync()
    {
        if (selectedSummary is null)
        {
            return;
        }

        isSyncing = true;
        detailFeedback = null;
        try
        {
            var detail = await MediaService.SyncMediaAsync(selectedSummary.Id);
            if (detail is not null)
            {
                selectedDetail = detail;
                updateModel.Priority = detail.Priority;
                updateModel.WatchState = detail.WatchState;
                updateModel.Hidden = detail.Hidden;
                updateModel.Source = detail.Source;
                updateModel.AvailableOn = detail.AvailableOn;
                updateModel.Notes = detail.Notes;

                UpsertSummary(detail);
                ApplyFilters();
                selectedSummary = library.FirstOrDefault(m => m.Id == detail.Id);

                if (detail.MediaType == MediaType.TvShow)
                {
                    episodes = (await MediaService.GetEpisodesAsync(detail.Id)).ToList();
                    ApplyEpisodeFilter();
                }
            }
        }
        catch (Exception ex)
        {
            detailFeedback = $"Refresh failed: {ex.Message}";
        }
        finally
        {
            isSyncing = false;
        }
    }

    private async Task UpdateEpisodeState(ViewState state)
    {
        if (selectedSummary is null || selectedEpisode is null)
        {
            return;
        }

        if (selectedEpisode.WatchState == state)
        {
            return;
        }

        try
        {
            var updated = await MediaService.UpdateEpisodeViewStateAsync(selectedSummary.Id, selectedEpisode.Id, state);
            if (updated is not null)
            {
                var index = episodes.FindIndex(e => e.Id == updated.Id);
                if (index >= 0)
                {
                    episodes[index] = updated;
                }
                ApplyEpisodeFilter();
                selectedEpisode = updated;

                // Auto-calculate media state for TV shows
                if (selectedDetail?.MediaType == MediaType.TvShow)
                {
                    await RecalculateMediaStateAsync();
                }
            }
        }
        catch (Exception ex)
        {
            detailFeedback = $"Episode update failed: {ex.Message}";
        }
    }

    private async Task<bool> ConfirmBulkUpdateAsync(string message)
    {
        try
        {
            return await JS.InvokeAsync<bool>("confirm", message);
        }
        catch
        {
            return false;
        }
    }

    private async Task RecalculateMediaStateAsync()
    {
        if (selectedSummary is null || selectedDetail?.MediaType != MediaType.TvShow)
        {
            return;
        }

        // Calculate new state based on episodes
        var s1PlusEpisodes = episodes.Where(e => e.SeasonNumber >= 1).ToList();

        if (s1PlusEpisodes.Count == 0)
        {
            // No regular episodes, leave state as is
            return;
        }

        ViewState newState;
        var allEpisodesUnwatched = episodes.All(e => e.WatchState == ViewState.Unwatched);
        var allS1PlusWatched = s1PlusEpisodes.All(e => e.WatchState == ViewState.Watched);

        if (allEpisodesUnwatched)
        {
            newState = ViewState.Unwatched;
        }
        else if (allS1PlusWatched)
        {
            newState = ViewState.Watched;
        }
        else
        {
            newState = ViewState.Partial;
        }

        // Only update if different
        if (updateModel.WatchState != newState)
        {
            updateModel.WatchState = newState;
            await SaveDetailChanges();
        }
    }

    private async Task<bool> ShouldShowZoomBannerAsync()
    {
        try
        {
            return await JS.InvokeAsync<bool>("myShowtimeState.shouldShowZoomBanner");
        }
        catch
        {
            return true;
        }
    }

    private async Task ReadLastSelectedMediaAsync()
    {
        try
        {
            var stored = await JS.InvokeAsync<string?>("myShowtimeState.getLastMediaId");
            if (!string.IsNullOrWhiteSpace(stored) && Guid.TryParse(stored, out var parsed))
            {
                lastSelectedMediaId = parsed;
            }
            else
            {
                lastSelectedMediaId = null;
            }
        }
        catch
        {
            lastSelectedMediaId = null;
        }
    }

    private async Task SaveLastSelectedMediaAsync(Guid? id)
    {
        try
        {
            if (id.HasValue)
            {
                await JS.InvokeVoidAsync("myShowtimeState.setLastMediaId", id.Value.ToString());
            }
            else
            {
                await JS.InvokeVoidAsync("myShowtimeState.clearLastMediaId");
            }
        }
        catch
        {
            // Ignored: persistence failures should not break UI flow.
        }
    }

    private async Task DismissBanner()
    {
        bannerVisible = false;
        try
        {
            await JS.InvokeVoidAsync("myShowtimeState.markZoomBannerDismissed");
        }
        catch
        {
            // ignore persistence errors
        }
    }

    private bool IsWatchStateSelected(ViewState state) => updateModel.WatchState == state;
    private bool IsEpisodeWatchState(ViewState state) => selectedEpisode?.WatchState == state;

    private string BuildPosterUrl(string path) => string.IsNullOrWhiteSpace(path) ? string.Empty : $"{PosterBaseUrl}{path}";

    private static string FormatDate(DateOnly? date) => date?.ToString("MMM dd, yyyy") ?? "Date TBD";
    private static string FormatRelease(string? date)
    {
        if (string.IsNullOrWhiteSpace(date))
        {
            return "Date TBD";
        }

        return DateTime.TryParse(date, out var parsed)
            ? parsed.ToString("yyyy", System.Globalization.CultureInfo.InvariantCulture)
            : date;
    }

    private static DateOnly? ParseReleaseDate(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return null;
        }

        return DateOnly.TryParse(value, out var parsed) ? parsed : null;
    }

    private static string FormatSearchType(TmdbSearchItemDto result)
        => GetSearchTypeKey(result);

    private static string GetSearchTypeKey(TmdbSearchItemDto item)
    {
        if (string.Equals(item.MediaType, "tv", StringComparison.OrdinalIgnoreCase))
        {
            return "Show";
        }

        if (string.Equals(item.MediaType, "movie", StringComparison.OrdinalIgnoreCase))
        {
            return "Movie";
        }

        if (string.IsNullOrWhiteSpace(item.MediaType))
        {
            return "Unknown";
        }

        return item.MediaType.ToUpperInvariant();
    }

    private static string FormatSource(string? value)
        => string.IsNullOrWhiteSpace(value) ? "-" : value!;

    private static string? BuildSortIndicator(string? activeColumn, string column, bool ascending)
        => string.Equals(activeColumn, column, StringComparison.OrdinalIgnoreCase)
            ? (ascending ? "^" : "v")
            : null;

    private static string FormatList(IEnumerable<string> values) => !values.Any() ? "Unknown" : string.Join(", ", values);

    private static string FormatEpisodeCode(EpisodeDto episode)
    {
        return $"S{episode.SeasonNumber:00}E{episode.EpisodeNumber:00}";
    }

    private string BuildMediaRowClasses(MediaSummaryDto item, bool isSelected)
    {
        var classes = new List<string> { "state-pill" };
        classes.Add(item.WatchState switch
        {
            ViewState.Watched => "row-watched",
            ViewState.Partial => "row-partial",
            _ => "row-unwatched"
        });
        if (item.Hidden)
        {
            classes.Add("row-hidden");
        }
        if (isSelected)
        {
            classes.Add("row-selected");
        }
        return string.Join(' ', classes);
    }

    private string BuildSearchRowClasses(TmdbSearchItemDto result, bool isSelected)
    {
        var classes = new List<string> { "state-pill" };
        if (isSelected)
        {
            classes.Add("row-selected");
        }
        if (string.Equals(result.MediaType, "person", StringComparison.OrdinalIgnoreCase))
        {
            classes.Add("row-person");
        }
        return string.Join(' ', classes);
    }

    private string BuildEpisodeRowClasses(EpisodeDto episode, bool isSelected)
    {
        var classes = new List<string> { "state-pill" };
        classes.Add(episode.WatchState switch
        {
            ViewState.Watched => "row-watched",
            ViewState.Partial => "row-partial",
            _ => "row-unwatched"
        });
        if (episode.IsSpecial)
        {
            classes.Add("row-special");
        }
        if (isSelected)
        {
            classes.Add("row-selected");
        }
        return string.Join(' ', classes);
    }

    private static string NormalizeSearchType(string? value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            return "multi";
        }

        var normalized = value.Trim().ToLowerInvariant();
        return normalized switch
        {
            "movie" => "movie",
            "tv" or "tvshow" or "television" => "tv",
            "media" => "multi",
            "person" => "person",
            _ => "multi"
        };
    }

    private static bool TryParseMediaType(string mediaType, out MediaType result)
    {
        var normalized = mediaType.Trim().ToLowerInvariant();
        switch (normalized)
        {
            case "movie":
                result = MediaType.Movie;
                return true;
            case "tv":
                result = MediaType.TvShow;
                return true;
            default:
                result = MediaType.Movie;
                return false;
        }
    }

    public void Dispose()
    {
        activeSearchRequestCts?.Cancel();
        activeSearchRequestCts?.Dispose();
        previewCts?.Cancel();
        previewCts?.Dispose();
        isDisposed = true;
    }

    private Task SafeStateHasChangedAsync()
    {
        return isDisposed ? Task.CompletedTask : InvokeAsync(StateHasChanged);
    }

    private void SafeStateHasChanged()
    {
        if (!isDisposed)
        {
            _ = InvokeAsync(StateHasChanged);
        }
    }
}
